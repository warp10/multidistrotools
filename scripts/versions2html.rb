#!/usr/bin/ruby
# 
# versions2html.rb
# - Lucas Nussbaum <lucas@lucas-nussbaum.net>
# 
# This script generates an HTML file from the list generated by
# compare-versions.bash
# you should have run compare-versions with :
# mdt compare-versions <a debian APT tree> <an Ubuntu APT tree>
#
# TODO/Bugs
# - only display MoM links when they exists
# - switch display of columns by javascript

require 'optparse'
require 'thread'
require 'net/http'
require 'rexml/document'
require 'uri'

$debianlinks = false
$debianbugs = nil
$ubuntubugs = false
$ubuntubugsextended = false
$ubuntubuildstatus = false
$ubuntulinks = false
$titleA = 'A'
$titleB = 'B'
$description = nil
$excluded = []
STATES = [ 'notinA', 'removedfromA', 'outdatedinA', 'outdatedandlocalinA', 'sameversionbutlocalinA', 'sameversionbutrebuildinA', 'sameversion', 'sameversionbutlocalinB', 'sameversionbutrebuildinB', 'sameversionbutlocalinboth', 'outdatedinB', 'outdatedandlocalinB', 'notinB', 'removedfromB' ]
$commentstitle = []
$commentsuri = []
$counts = Hash::new(0)
$texts = Hash::new("")
$labels = Hash::new

opts = OptionParser::new do |opts|
  opts.banner = "Usage: mdt versions2html [options] < versions-list"
  opts.separator ""
  opts.separator "Options:"
  opts.on("-d", "--debian-links", "Include Debian-related links in the output") do
    $debianlinks = true
  end
  opts.on("-u", "--ubuntu-links", "Include Ubuntu-related links in the output") do
    $ubuntulinks = true
  end
  opts.on("-e", "--debian-bugs BUGS.TXT", "Fetch Debian bugs") do |f|
    $debianbugs = f
  end
  opts.on("-f", "--ubuntu-bugs", "Fetch Ubuntu bugs") do
    $ubuntubugs = true
  end
  opts.on("-g", "--ubuntu-bugs-extended", "Fetch Ubuntu bugs (Extended info)") do
    $ubuntubugsextended = true
  end
  opts.on("-h", "--ubuntu-build-status", "Fetch Ubuntu build status") do
    $ubuntubuildstatus = true
  end
  opts.on("-t", "--title TITLE", "Title of page") do |t|
    $title = t
  end
  if not $title
    $title = "Package"
  end
  opts.on("-a", "--titleA TITLE", "Title of first column") do |t|
    $titleA = t
  end
  opts.on("-b", "--titleB TITLE", "Title of first column") do |t|
    $titleB = t
  end
  opts.on("-s", "--description DESCRIPTION", "Description for the list") do |s|
    $description = s
  end
  opts.on("-x", "--exclude STATE", "Exclude type from output") do |t|
    if not STATES.include?(t)
      puts "Unknown state: #{t} ! Valid states are #{STATES.join[' ']}."
      exit(1)
    end
    $excluded << t
  end
  opts.on("-c", "--comment-title COMMENTTITLE", "Set command title (eg: \"0,Title for column 0\")") do |t|
    n, c = t.split(',',2)
    $commentstitle[n.to_i] = c
  end
  opts.on("-c", "--comment-uri COMMENTURI", "Set command uri (eg: \"0,http://www.perdu.com/\")") do |t|
    n, c = t.split(',',2)
    $commentsuri[n.to_i] = c
  end
end
opts.parse!(ARGV)


# labels
$labels['notinA'] = "Not in #{$titleA}"
$labels['removedfromA'] = "Removed from #{$titleA}"
$labels['outdatedinA'] = "Outdated in #{$titleA} (#{$titleB} version &gt; #{$titleA} version)"
$labels['outdatedandlocalinA'] = "Outdated in #{$titleA} (#{$titleB} version &gt; #{$titleA} version), and #{$titleA} has local changes"
$labels['notinB'] = "Not in #{$titleB}"
$labels['removedfromB'] = "Removed from #{$titleB}"
$labels['outdatedinB'] = "Outdated in #{$titleB} (#{$titleA} version &gt; #{$titleB} version)"
$labels['outdatedandlocalinB'] = "Outdated in #{$titleB} (#{$titleA} version &gt; #{$titleB} version), and #{$titleB} has local changes"
$labels['sameversionbutlocalinA'] = "Same version, but #{$titleA} has local changes"
$labels['sameversionbutlocalinB'] = "Same version, but #{$titleB} has local changes"
$labels['sameversionbutrebuildinA'] = "Same version, but #{$titleA} has been rebuilt"
$labels['sameversionbutrebuildinB'] = "Same version, but #{$titleB} has been rebuilt"
$labels['sameversion'] = "Same version in #{$titleA} and #{$titleB}"
$labels['sameversionbutlocalinboth'] = "Same version, but both #{$titleA} and #{$titleB} have local changes"

# Parse comments.
# text file with format: pkgname Aversion (or ANY, or >=|>X) Bversion (or ANY, or >=|>X)
$comments = []
Comment = Struct::new("Comment", :title, :uri, :data, :used)
$commentstitle.each_with_index do |t, i|
  if $commentsuri[i]
    c = Comment::new
    c.title = $commentstitle[i]
    c.uri = $commentsuri[i]
    c.data = Hash::new
    # do the parsing
    begin
      if c.uri =~ /http:\/\//
        str = Net::HTTP::get(URI::parse(c.uri))
      else
        str = IO::read(c.uri)
        c.uri = 'file://' + c.uri
      end
      str.each_line do |l|
        pkg, d, u, com = l.split(/\s/, 4)
        c.data[pkg] = {} if c.data[pkg].nil?
        c.data[pkg][[d, u]] = com
      end
      $comments << c
    rescue
      STDERR.puts "Exception while parsing #{c.uri}: #{$!}"
      STDERR.puts $!.backtrace.join("\n")
      # do nothing else on purpose
    end
  end
end

def header
  puts <<-EOF
<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

	<title>#{$title} versions
  EOF
  if $titleA and $titleB
    puts " in #{$titleA} and #{$titleB}"
  end
  puts <<-EOF
  </title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
  <style type="text/css">
body {
	font-size: 10px;
	font-family: Verdana, Arial, Helvetica, sans-serif;
}

h1 {
  text-align: center;
}

table.pkglist {
  border-collapse: collapse;
  border: 2px solid black;
}

table.pkglist td, table.pkglist th {
  border: 1px solid black;
  padding: 2px;
}

tr.notinA {
  background-color: #b0aaff;
}

tr.outdatedinA {
  background-color: #c6feff;
}

tr.sameversionbutlocalinA {
  background-color: #ff14ff;
}

tr.sameversion {
  background-color: white;
}

tr.sameversionbutlocalinB {
  background-color: #ffd4ff;
}

tr.sameversionbutlocalinboth {
  background-color: #ff84ff;
}

tr.outdatedinB {
  background-color: #ffe3b8;
}

tr.notinB {
  background-color: #ff8989;
}

div.nicetitle {
    position: absolute;
    padding: 4px;
    top: 0px;
    left: 0px;
    width: 40em;
    font-weight: bold;
    background-color: #ffffa0;
	 border: 1px solid black;
}
div.nicetitle pre {
    margin: 0;
	 padding: 0 3px;
}
div.nicetitle p.destination {
    padding-top: 3px;
	 font-weight: bold;
}
  </style>
  EOF
  if $ubuntubugs or $ubuntubugsextended
    puts <<-EOF
  <script type="text/javascript">
  <!--
addEvent(window, "load", makeNiceTitles);

var XHTMLNS = "http://www.w3.org/1999/xhtml";
var CURRENT_NICE_TITLE;
var browser = new Browser();

function makeNiceTitles() {
    if (!document.createElement || !document.getElementsByTagName) return;
    // add namespace methods to HTML DOM; this makes the script work in both
    // HTML and XML contexts.
    if(!document.createElementNS)
    {
        document.createElementNS = function(ns,elt) {
            return document.createElement(elt);
        }
    }

    if( !document.links )
    {
        document.links = document.getElementsByTagName("a");
    }
    for (var ti=0;ti<document.links.length;ti++) {
        var lnk = document.links[ti];
        if (lnk.title) {
            lnk.setAttribute("nicetitle",lnk.title);
            lnk.removeAttribute("title");
            addEvent(lnk,"mouseover",showNiceTitle);
            addEvent(lnk,"mouseout",hideNiceTitle);
            addEvent(lnk,"focus",showNiceTitle);
            addEvent(lnk,"blur",hideNiceTitle);
        }
    }
}

function findPosition( oLink ) {
  if( oLink.offsetParent ) {
    for( var posX = 0, posY = 0; oLink.offsetParent; oLink = oLink.offsetParent ) {
      posX += oLink.offsetLeft;
      posY += oLink.offsetTop;
    }
    return [ posX, posY ];
  } else {
    return [ oLink.x, oLink.y ];
  }
}

function showNiceTitle(e) {
    if (CURRENT_NICE_TITLE) hideNiceTitle(CURRENT_NICE_TITLE);
    if (!document.getElementsByTagName) return;
    if (window.event && window.event.srcElement) {
        lnk = window.event.srcElement
    } else if (e && e.target) {
        lnk = e.target
    }
    if (!lnk) return;
    if (lnk.nodeType == 3) {
        // lnk is a textnode -- ascend parents until we hit a link
        lnk = getParent(lnk,"A");
    }
    if (!lnk) return;
    nicetitle = lnk.getAttribute("nicetitle");
	 if (!nicetitle) return;
    
    var d = document.createElementNS(XHTMLNS,"div");
    d.className = "nicetitle";
    tnt = document.createTextNode(nicetitle);
    pat = document.createElementNS(XHTMLNS,"pre");
    pat.className = "titletext";
    pat.appendChild(tnt);
    d.appendChild(pat);
    if (lnk.href) {
        tnd = document.createTextNode(lnk.href);
        pad = document.createElementNS(XHTMLNS,"p");
        pad.className = "destination";
        pad.appendChild(tnd);
        d.appendChild(pad);
    }
    
    STD_WIDTH = 300;
    if (lnk.href) {
        h = lnk.href.length;
    } else { h = nicetitle.length; }
    if (nicetitle.length) {
      t = nicetitle.length;
    }
    h_pixels = h*6; t_pixels = t*10;
    
    if (h_pixels > STD_WIDTH) {
        w = h_pixels;
    } else if ((STD_WIDTH>t_pixels) && (t_pixels>h_pixels)) {
        w = t_pixels;
    } else if ((STD_WIDTH>t_pixels) && (h_pixels>t_pixels)) {
        w = h_pixels;
    } else {
        w = STD_WIDTH;
    }
        
    d.style.width = w + 'px';    

    /*
    mx = lnk.offsetLeft;
    my = lnk.offsetTop;
    */
    mpos = findPosition(lnk);
    mx = mpos[0];
    my = mpos[1];
    //xy = getMousePosition(e);
    //mx = xy[0]; my = xy[1];
    
    d.style.left = (mx+15) + 'px';
    d.style.top = (my+35) + 'px';
    if (window.innerWidth && ((mx+w) > window.innerWidth)) {
        d.style.left = (window.innerWidth - w - 25) + "px";
    }
    if (document.body.scrollWidth && ((mx+w) > document.body.scrollWidth)) {
        d.style.left = (document.body.scrollWidth - w - 25) + "px";
    }
    
    document.getElementsByTagName("body")[0].appendChild(d);
    
    CURRENT_NICE_TITLE = d;
}

function hideNiceTitle(e) {
    if (!document.getElementsByTagName) return;
    if (CURRENT_NICE_TITLE) {
        document.getElementsByTagName("body")[0].removeChild(CURRENT_NICE_TITLE);
        CURRENT_NICE_TITLE = null;
    }
}

// Add an eventListener to browsers that can do it somehow.
// Originally by the amazing Scott Andrew.
function addEvent(obj, evType, fn){
  if (obj.addEventListener){
    obj.addEventListener(evType, fn, true);
    return true;
  } else if (obj.attachEvent){
	var r = obj.attachEvent("on"+evType, fn);
    return r;
  } else {
	return false;
  }
}

function getParent(el, pTagName) {
	if (el == null) return null;
	else if (el.nodeType == 1 && el.tagName.toLowerCase() == pTagName.toLowerCase())	// Gecko bug, supposed to be uppercase
		return el;
	else
		return getParent(el.parentNode, pTagName);
}

function getMousePosition(event) {
  if (browser.isIE) {
    x = window.event.clientX + document.documentElement.scrollLeft
      + document.body.scrollLeft;
    y = window.event.clientY + document.documentElement.scrollTop
      + document.body.scrollTop;
  }
  if (browser.isNS) {
    x = event.clientX + window.scrollX;
    y = event.clientY + window.scrollY;
  }
  return [x,y];
}

// Determine browser and version.

function Browser() {
// blah, browser detect, but mouse-position stuff doesn't work any other way
  var ua, s, i;

  this.isIE    = false;
  this.isNS    = false;
  this.version = null;

  ua = navigator.userAgent;

  s = "MSIE";
  if ((i = ua.indexOf(s)) >= 0) {
    this.isIE = true;
    this.version = parseFloat(ua.substr(i + s.length));
    return;
  }

  s = "Netscape6/";
  if ((i = ua.indexOf(s)) >= 0) {
    this.isNS = true;
    this.version = parseFloat(ua.substr(i + s.length));
    return;
  }

  // Treat any other "Gecko" browser as NS 6.1.

  s = "Gecko";
  if ((i = ua.indexOf(s)) >= 0) {
    this.isNS = true;
    this.version = 6.1;
    return;
  }
}
  -->
  </script>
    EOF
  end
  puts <<-EOF
</head>

<body>
<h1>#{$title} versions
  EOF
  if $titleA and $titleB
    puts " in #{$titleA} and #{$titleB}"
  end
  puts "</h1>"
  if $description
    puts "<h2>Description</h2>"
    puts "<p style=\"font-weigth: bold; font-size: normal;\">#{$description}</p>"
  end
end

def footer
  puts <<-EOF
<hr/>
<p>Generated using <a href="https://wiki.ubuntu.com/MultiDistroTools">MultiDistroTools</a> on #{Time::now.utc.to_s}</p>
</body>
</html>
  EOF
end

def tableheader
  puts <<-EOF
<table class="pkglist">
<tr><th>Package</th><th>#{$titleA}</th><th>#{$titleB}</th>
  EOF
  puts "<th>Debian Links</th>" if $debianlinks
  puts "<th>Ubuntu Links</th>" if $ubuntulinks
  puts "<th>Ubuntu Bugs</th>" if $ubuntubugs or $ubuntubugsextended
  puts "<th>Debian Bugs</th>" if $debianbugs
  puts "<th>Ubuntu Build Problems</th>" if $ubuntubuildstatus
  $comments.each do |c|
    puts "<th><a href=\"#{c.uri}\">#{c.title}</a></th>\n"
  end
  puts "</tr>"
end

def tablefooter
  puts <<-EOF
  </table>
  EOF
end

def caption
  puts "<h2>Summary</h2><table class=\"pkglist\">"
  STATES.each do |s|
    if not $excluded.include?(s) and $counts[s] > 0
      puts "<tr class=\"#{s}\"><td><a href=\"##{s}\">#{$labels[s]} : #{$counts[s]} packages</a></td></tr>"
    end
  end
  puts "</table>"
end

def showversion(va, vb)
  if va == "NOTFOUND"
    state = "notinA"
  elsif vb == "NOTFOUND"
    state = "notinB"
  elsif va == "REMOVED"
    state = "removedfromA"
  elsif vb == "REMOVED"
    state = "removedfromB"
  elsif va == vb
    state = "sameversion"
  elsif va == vb.sub(/ubuntu.*/, '')
    state = "sameversionbutlocalinB"
  elsif vb == va.sub(/ubuntu.*/, '')
    state = "sameversionbutlocalinA"
  elsif va == vb.sub(/build.*/, '')
    state = "sameversionbutrebuildinB"
  elsif vb == va.sub(/build.*/, '')
    state = "sameversionbutrebuildinA"
  elsif va.sub(/(ubuntu|build).*/, '') == vb.sub(/(ubuntu|build).*/, '')
    state = "sameversionbutlocalinboth"
  else
    i = IO::popen("dpkg --compare-versions #{va} lt #{vb}; echo $?")
    case i.read.to_i
    when 1
      if vb != vb.sub(/(ubuntu|build).*/, '')
        state = "outdatedandlocalinB"
      else
        state = "outdatedinB"
      end
    else
      if va != va.sub(/(ubuntu|build).*/, '')
        state = "outdatedandlocalinA"
      else
        state = "outdatedinA"
      end
    end
    i.close
  end
  return state
end

def getpooladdr(name)
  if name =~ /^lib/
    return name[0..3] + '/' + name
  else
    return name[0].chr + '/' + name
  end
end

require 'net/https'
require 'uri'

def mergelink(package)
  u = "http://merges.ubuntu.com/#{getpooladdr(package)}/"
  #uri = URI::parse(u)
  #http = Net::HTTP::new(uri.host, uri.port)
  #r = http::get(uri.request_uri)
  #if r.response.kind_of?(Net::HTTPOK)
    return "<a href=\"#{u}\"><b>Merge</b></a>&nbsp;"
  #else
  #  return ""
  #end
end

def patchlink(package, b)
  u = "http://patches.ubuntu.com/#{getpooladdr(package)}/#{package}_#{b}.patch"
  #uri = URI::parse(u)
  #http = Net::HTTP::new(uri.host, uri.port)
  #r = http::get(uri.request_uri)
  #if r.response.kind_of?(Net::HTTPOK)
    return "<a href=\"#{u}\"><b>Patch</b></a>&nbsp;"
  #else
  #  return ""
  #end
end
  
def fetch_bugs_for_package(pkg)
  uri = URI::parse("https://launchpad.net/ubuntu/+source/#{pkg}/+bugs-text")
  http = Net::HTTP::new(uri.host, uri.port)
  if uri.scheme == 'https'
    http.use_ssl = true 
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
  end
  str = http::get(uri.request_uri)
  if str.response.kind_of?(Net::HTTPOK)
    return str.body.split
  else
    STDERR.puts "Error on #{uri}: #{str.response}"
    return []
  end
end

class LPBug
  attr_reader :text, :severity, :status, :title
  def initialize(text = nil)
    parse(text) if text
  end

  ST = Hash::new(10)
  ST[' Fix Released'] = 2
  ST[' Invalid'] = 2
  ST[' Won\'t Fix'] = 2
  ST[' Unknown'] = 1
  ST[nil] = 0
  def parse(text)
    @text = text
    @text.each_line do |l|
      k, v = l.split(':', 2)
      if k == 'title'
        @title = v.chomp
      elsif k == 'status'
        v = v.chomp
        if ST[v] > ST[@status]
          @status = v
        end
      elsif k == 'severity'
        @severity = v.chomp
      end
    end
    self
  end

  def to_s
    @text
  end
end

def fetch_bug(number)
  uri = URI::parse("https://launchpad.net/bugs/#{number}/+text")
  http = Net::HTTP::new(uri.host, uri.port)
  if uri.scheme == 'https'
    http.use_ssl = true 
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
  end
  str = http::get(uri.request_uri)
  if str.response.kind_of?(Net::HTTPOK)
    return LPBug::new(str.body)
  else
    STDERR.puts "Error on #{uri}: #{str.response}"
    return LPBug::new
  end
end

# Main processing begins here
header

if $debianbugs
  $dbugs = {}
  s = IO::read($debianbugs)
  s.each_line do |l|
    p, c = l.split(':', 2)
    $dbugs[p] = c
  end
end

$linesread = []

PkgLine = Struct::new(:package, :a, :b, :state, :bugs, :builds)

STDIN.read.each_line do |l|
  pl = PkgLine::new
  pl.package, pl.a, pl.b = l.split(' ')
  $linesread << pl
end

# Fetch state and build $lines
$lines = []
m = Mutex::new
ths = []
$linesread.each do |pl|
  ths << Thread::new(pl) do |pl|
    pl.state = showversion(pl.a, pl.b)
    if not $excluded.include?(pl.state)
      m.synchronize do
        $lines << pl
      end
    end
  end
  ths.each { |t| t.join }
end

if $ubuntubugs or $ubuntubugsextended
# Do all the bug fetching
  ths = []
  $bugsh = {}
  m = Mutex::new
  $lines.each do |pl|
    ths << Thread::new(pl) do |pl|
      pl.bugs = fetch_bugs_for_package(pl.package)
      STDERR.puts "Fetched bugs for #{pl.package}."
      if $ubuntubugsextended
        thls = []
        pl.bugs.each do |b|
          thls << Thread::new(b) do |b|
            bug = fetch_bug(b)
            m.synchronize do
              $bugsh[b] = bug
            end
            STDERR.puts "Fetched bug #{b} for #{pl.package}."
          end
        end
        thls.each { |t| t.join }
      end
    end
  end
  ths.each { |t| t.join }
end

if $ubuntubuildstatus
  ths = []
  $lines.each do |pl|
    ths << Thread::new(pl) do |pl|
      uri = URI::parse("https://launchpad.net/ubuntu/+source/#{pl.package}/#{pl.b}")
      http = Net::HTTP::new(uri.host, uri.port)
      if uri.scheme == 'https'
        http.use_ssl = true 
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      end
      str = http::get(uri.request_uri)
      if str.response.kind_of?(Net::HTTPOK)
        # Launchpad is not valid XHTML, which makes it a PITA to parse.
        t = str.body.match(/<h4>Builds of[^<]*<\/h4>(.*)/m)[1]
        t2 = t.gsub(/<\/div>.*/m,'') + '</div>'
        d = REXML::Document::new(t2)
        pl.builds = ''
        d.each_element('/div/ul/li') do |e|
          url = e.elements['a'].attribute('href').value
          target = e.elements['a'].to_s.gsub(/<[^>]*>/m,'').gsub(/\s+/m,' ')
          ok = (e.to_s =~ /Successfully built/)
          needs = (e.to_s =~ /Needs building/)
          if !ok
            s = "<a href=\"#{url}\">"
            s += '<span style="color: red">' if !needs
            s += target
            s += '</span>' if !needs
            s += '</a>'
            pl.builds << ', ' if pl.builds != ''
            pl.builds << s
          end
        end
      else
        STDERR.puts "Error on #{uri}: #{str.response}"
        pl.builds = "<b>Error</b>"
      end
    end
  end
  ths.each { |t| t.join }
end

$lines.each do |pl|
  state = pl.state
  package = pl.package
  a = pl.a
  b = pl.b
  if not $excluded.include?(state)
    s = "<tr class=\"#{state}\"><td>#{package}</td>\n<td>#{a}</td>\n<td>#{b}</td>\n"
    if $debianlinks
      s += "<td><a href=\"http://packages.qa.debian.org/#{package}\">PTS</a>&nbsp;"
      s += "<a href=\"http://bugs.debian.org/src:#{package}\">BTS</a>&nbsp;"
      s += "<a href=\"http://changelog.debian.net/#{package}\">changes</a>&nbsp;"
      s += "<a href=\"http://buildd.debian.org/build.php?arch=&amp;pkg=#{package}\">buildlog</a> \n"
      s += "</td>\n"
    end
    if $ubuntulinks
      s += "<td><a href=\"http://packages.ubuntu.com/src:#{package}\">p.u.c</a>&nbsp;"
      s += mergelink(package) if state == 'outdatedandlocalinB'
      s += "<a href=\"https://launchpad.net/ubuntu/+source/#{package}\">LP</a>&nbsp;"
      s += patchlink(package,b) if (state == 'sameversionbutrebuildinB') || (state == 'sameversionbutlocalinB') || (state == 'outdatedandlocalinB')
      s += "<a href=\"https://launchpad.net/ubuntu/+source/#{package}/+bugs\">bugs</a>&nbsp;"
      s += "<a href=\"https://launchpad.net/ubuntu/+source/#{package}/#{b}\">builds</a>&nbsp;"
      s += "<a href=\"http://changelogs.ubuntu.com/changelogs/pool/universe/#{getpooladdr(package)}/#{package}_#{b}/changelog\">changes</a>"
      s += "</td>\n"
    end
    if $ubuntubugs or $ubuntubugsextended
      s += "<td>"
      pl.bugs.each do |b|
        if $ubuntubugsextended
          bug = $bugsh[b]
          next if bug.status == ' Fix Released' or bug.status == ' Invalid' or bug.status == ' Won\'t Fix'
          s += "<a href=\"https://launchpad.net/bugs/#{b}\" title=\"#{bug.text}\">#{b}</a> "
        else
          s += "<a href=\"https://launchpad.net/bugs/#{b}\">#{b}</a> "
        end
      end
      s += "</td>"
    end
    if $debianbugs
      s += "<td><a href=\"http://bugs.debian.org/src:#{package}\">#{$dbugs[package]}</a>"
    end
    if $ubuntubuildstatus
      s += "<td>#{pl.builds}</td>"
    end
    $comments.each do |c|
      found = false
      if c.data[package]
        c.data[package].each_pair do |versions, comment|
          # TODO deal with versions
          s+= "<td>#{comment}</td>\n"
          found = true
        end
      end
      if not found
        s+= "<td></td>\n"
      end
    end
    s += "</tr>\n\n"
    $texts[state] += s
    $counts[state] += 1
  end
end

# displaying
caption

STATES.each do |state|
  if not $excluded.include?(state) and $counts[state] > 0
    puts "<h2><a id=\"#{state}\" />#{$labels[state]} : #{$counts[state]} packages</h2>"
    tableheader
    puts $texts[state]
    tablefooter
  end
end

if $debianlinks or $ubuntulinks
  puts <<-EOF
<h2>Other useful links</h2>
<ul>
  EOF
  if $debianlinks
    puts <<-EOF
  <li>ftp-master.d.o :
  <ul><li><a href="http://ftp-master.debian.org/new.html">NEW packages</a></li>
  <li><a href="http://ftp-master.debian.org/removals.txt">log of packages removal</a></li></ul>
  </li>
    EOF
  end
  if $ubuntulinks
    puts <<-EOF
    EOF
  end
  puts <<-EOF
</ul>
  EOF
end
if $debianbugs
    puts <<-EOF
<h2>Debian bugs meaning</h2>
<ul>
  <li>RC (critical, grave, serious)</li>
  <li>IN (important, normal)</li>
  <li>MW (minor, wishlist)</li>
  <li>FP (fixed, pending upload)</li>
  <li>Between (): same, but merged bugs count only once</li>
</ul>
  EOF
end

footer
